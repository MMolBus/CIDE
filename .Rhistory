# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
wd
librarian::shelf("devtools", "roxygen2", "testthat", "knitr", "bookdown")
# install required packages an libraries
librarian::shelf(exiftoolr, raster, dplyr, stringr, jpeg, MMolbus/MButils, tiff, OpenImageR, gatepoints)
##set working directory------------------------------------------------------------------
## general wd: copy your wd path as text and run as is the next line
wd <-
getpath()
wd
setwd(wd)
getwd()
pic_wd <-
list.dirs(wd, recursive = T)[
grep("JPG$",  list.dirs(wd, recursive = T))
]
# roi directory
roi_wd <-
list.dirs(wd, recursive = T)[
grep("rois$",  list.dirs(wd, recursive = T))
]
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
# install required packages an libraries
librarian::shelf(exiftoolr, raster, dplyr, stringr, jpeg, MMolbus/MButils, tiff, OpenImageR, gatepoints, rgeos)
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
pic.path="./JPG"
samp.width = 0.01
pic.format = "jpg"
chartf <- function(pic.path,
samp.width,
pic.format) {
if (require(jpeg) == F) {
install.packages("jpeg")
library(jpeg)
}
if (require(raster) == F) {
install.packages("raster")
library(raster)
}
if (pic.format == "jpg") {
file <-
list.files(path = pic.path ,
pattern = ".jpg$|.JPG$|.jpeg$",
full.names = T)[1]
pic <- jpeg::readJPEG(file)
}
if (pic.format == "tif") {
file <- list.files(path = "./vis",
pattern = ".tif$",
full.names = T)[1]
pic <- tiff::readTIFF(file)
}
pic.1 <- raster::raster(pic[, , 1])
pic.2 <- raster::raster(pic[, , 2])
pic.3 <- raster::raster(pic[, , 3])
pic.raster <- raster::stack(pic.1,
pic.2,
pic.3)
options(warn = -1)
op <-
par(
mfrow = c(1, 1),
mar = c(0, 0, 0, 0),
oma = c(0, 0, 0, 0)
)
on.exit(par(op))
X11()
raster::plotRGB(pic.raster,
scale = 1,
asp = nrow(pic.1) / ncol(pic.1))
options(warn = 0)
# chart.coords <- data.frame(x = numeric(), y = numeric())
message(
"Color chart has 6 columns and 4 rows. Bottom row correspond to grayscale tiles. Click on all 24 color chart cells in sequence. The sequence follows left to right as follows: starts at cell 1 (brown, top left) and finishes on cell 24 (black, bottom right)."
)
# for (i in 1:24) {
#   options(warn = -1)
#   chart.coords[i, 1:2] <- click(xy = T)[1:2]
#   options(warn = 0)
# }
chart.coords <- locator(n = 24, type = "p")
chart.coords <- cbind(chart.coords[[1]], chart.coords[[2]])
colnames(chart.coords) <- c("x", "y")
sp.chart <- sp::SpatialPoints(chart.coords)
chart_buff <-
rgeos::gBuffer(sp.chart, width = samp.width, byid = T)
# plot(chart_buff, add = T, col = "green")
return(chart_buff)
}
chart <- chartf(pic.path = pic.path,
samp.width = samp.width,
pic.format = pic.format)
chart
plot(chart, add = T, col = "green")
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
chart
rm(chart)
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
chart
chartf <- function(pic.path,
samp.width,
pic.format) {
if (require(jpeg) == F) {
install.packages("jpeg")
library(jpeg)
}
if (require(raster) == F) {
install.packages("raster")
library(raster)
}
if (pic.format == "jpg") {
file <-
list.files(path = pic.path ,
pattern = ".jpg$|.JPG$|.jpeg$",
full.names = T)[1]
pic <- jpeg::readJPEG(file)
}
if (pic.format == "tif") {
file <- list.files(path = "./vis",
pattern = ".tif$",
full.names = T)[1]
pic <- tiff::readTIFF(file)
}
pic.1 <- raster::raster(pic[, , 1])
pic.2 <- raster::raster(pic[, , 2])
pic.3 <- raster::raster(pic[, , 3])
pic.raster <- raster::stack(pic.1,
pic.2,
pic.3)
options(warn = -1)
op <-
par(
mfrow = c(1, 1),
mar = c(0, 0, 0, 0),
oma = c(0, 0, 0, 0)
)
on.exit(par(op))
X11()
raster::plotRGB(pic.raster,
scale = 1,
asp = nrow(pic.1) / ncol(pic.1))
options(warn = 0)
# chart.coords <- data.frame(x = numeric(), y = numeric())
message(
"Color chart has 6 columns and 4 rows. Bottom row correspond to grayscale tiles. Click on all 24 color chart cells in sequence. The sequence follows left to right as follows: starts at cell 1 (brown, top left) and finishes on cell 24 (black, bottom right)."
)
# for (i in 1:24) {
#   options(warn = -1)
#   chart.coords[i, 1:2] <- click(xy = T)[1:2]
#   options(warn = 0)
# }
chart.coords <- locator(n = 24, type = "p")
chart.coords <- cbind(chart.coords[[1]], chart.coords[[2]])
colnames(chart.coords) <- c("x", "y")
sp.chart <- sp::SpatialPoints(chart.coords)
chart_buff <-
rgeos::gBuffer(sp.chart, width = samp.width, byid = T)
# plot(chart_buff, add = T, col = "green")
return(chart_buff)
}
chart <- chartf(pic.path = pic.path,
samp.width = samp.width,
pic.format = pic.format)
chart
chartf <- function(pic.path,
samp.width,
pic.format) {
if (require(jpeg) == F) {
install.packages("jpeg")
library(jpeg)
}
if (require(raster) == F) {
install.packages("raster")
library(raster)
}
if (pic.format == "jpg") {
file <-
list.files(path = pic.path ,
pattern = ".jpg$|.JPG$|.jpeg$",
full.names = T)[1]
pic <- jpeg::readJPEG(file)
}
if (pic.format == "tif") {
file <- list.files(path = "./vis",
pattern = ".tif$",
full.names = T)[1]
pic <- tiff::readTIFF(file)
}
pic.1 <- raster::raster(pic[, , 1])
pic.2 <- raster::raster(pic[, , 2])
pic.3 <- raster::raster(pic[, , 3])
pic.raster <- raster::stack(pic.1,
pic.2,
pic.3)
options(warn = -1)
op <-
par(
mfrow = c(1, 1),
mar = c(0, 0, 0, 0),
oma = c(0, 0, 0, 0)
)
on.exit(par(op))
X11()
raster::plotRGB(pic.raster,
scale = 1,
asp = nrow(pic.1) / ncol(pic.1))
options(warn = 0)
# chart.coords <- data.frame(x = numeric(), y = numeric())
message(
"Color chart has 6 columns and 4 rows. Bottom row correspond to grayscale tiles. Click on all 24 color chart cells in sequence. The sequence follows left to right as follows: starts at cell 1 (brown, top left) and finishes on cell 24 (black, bottom right)."
)
# for (i in 1:24) {
#   options(warn = -1)
#   chart.coords[i, 1:2] <- click(xy = T)[1:2]
#   options(warn = 0)
# }
chart.coords <- locator(n = 24, type = "p")
chart.coords <- cbind(chart.coords[[1]], chart.coords[[2]])
colnames(chart.coords) <- c("x", "y")
sp.chart <- sp::SpatialPoints(chart.coords)
chart_buff <-
rgeos::gBuffer(sp.chart, width = samp.width, byid = T)
# plot(chart_buff, add = T, col = "green")
plot(chart_buff, add = T, col = "green")
return(chart_buff)
}
chart <- chartf(pic.path = pic.path,
samp.width = samp.width,
pic.format = pic.format)
source("~/GitHub/CIDE/R/chart2.R")
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
##set working directory------------------------------------------------------------------
## general wd: copy your wd path as text and run as is the next line
gitwd <- getpath()
setwd(gitwd)
gitwd
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
rm(list = c("chart2"))
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
source("~/GitHub/CIDE/R/chart2.R")
## get chart tiles positions using chart.from.jpg function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
edit_r_profile()
usethis::use_package("raster", "dplyr", "stringr", "jpeg",
"tiff", "OpenImageR", "gatepoints", "rgeos") # Default is "Imports"
usethis::use_package(c("raster", "dplyr", "stringr", "jpeg",
"tiff", "OpenImageR", "gatepoints", "rgeos")) # Default is "Imports"
usethis::use_package("raster")
usethis::use_package("dplyr")
usethis::use_package("stringr")
usethis::use_package("jpeg")
usethis::use_package("tiff")
usethis::use_package("OpenImageR")
usethis::use_package("gatepoints")
usethis::use_package("rgeos") # Default is "Imports"
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
rm(list = c("chart2"))
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
wd
getwd()
getwd()
getwd()
source("~/GitHub/CIDE/R/chart2.R")
source("~/GitHub/CIDE/R/chart2.R")
source("~/GitHub/CIDE/R/chart2.R")
source("~/GitHub/CIDE/R/chart2.R")
source("~/GitHub/CIDE/R/chart2.R")
knit_with_parameters("~/GitHub/CIDE/tutorial/tutorial.Rmd")
install.packages("rmarkdown")
library(rmarkdown)
install.packages("librarian")
install.packages("librarian")
librarian::shelf("devtools", "roxygen2", "testthat", "knitr", "bookdown")
# install devtools--------------------------------------------------------------
library(devtools)
packageVersion("devtools")
# test drive function strsplit1-----------------------------------------------------------
# If this were a regular R script, we might use RStudio to send the function
# definition to the R Console and define strsplit1() in the global environment.
# Or maybe we’d call source("R/strsplit1.R"). For package development, however,
# devtools offers a more robust approach.
# Call load_all() to make strsplit1() available for experimentation.
devtools::load_all()
??chart2
wd <-
getpath()
setwd(wd)
getwd()
# install required packages an libraries
librarian::shelf(exiftoolr, raster, dplyr, stringr, jpeg, MMolbus/MButils, tiff, OpenImageR, gatepoints, rgeos)
wd <-
getpath()
wd
setwd(wd)
getwd()
pic_wd <-
list.dirs(wd, recursive = T)[
grep("JPG$",  list.dirs(wd, recursive = T))
]
# roi directory
roi_wd <-
list.dirs(wd, recursive = T)[
grep("rois$",  list.dirs(wd, recursive = T))
]
## get chart tiles positions using chart2 function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
chart2 <- function(pic.path,
samp.width = 0.01,
pic.format){
# chartf <- function(pic.path,
#                    samp.width,
#                    pic.format) {
if (require(jpeg) == F) {
install.packages("jpeg")
library(jpeg)
}
if (require(raster) == F) {
install.packages("raster")
library(raster)
}
if (pic.format == "jpg") {
file <-
list.files(path = pic.path ,
pattern = ".jpg$|.JPG$|.jpeg$",
full.names = T)[1]
pic <- jpeg::readJPEG(file)
}
if (pic.format == "tif") {
file <- list.files(path = "./vis",
pattern = ".tif$",
full.names = T)[1]
pic <- tiff::readTIFF(file)
}
pic.1 <- raster::raster(pic[, , 1])
pic.2 <- raster::raster(pic[, , 2])
pic.3 <- raster::raster(pic[, , 3])
pic.raster <- raster::stack(pic.1,
pic.2,
pic.3)
options(warn = -1)
op <-
par(
mfrow = c(1, 1),
mar = c(0, 0, 0, 0),
oma = c(0, 0, 0, 0)
)
on.exit(par(op))
X11()
raster::plotRGB(pic.raster,
scale = 1,
asp = nrow(pic.1) / ncol(pic.1))
options(warn = 0)
# chart.coords <- data.frame(x = numeric(), y = numeric())
message(
"Color chart has 6 columns and 4 rows. Bottom row correspond to grayscale tiles. Click on all 24 color chart cells in sequence. The sequence follows left to right as follows: starts at cell 1 (brown, top left) and finishes on cell 24 (black, bottom right)."
)
# for (i in 1:24) {
#   options(warn = -1)
#   chart.coords[i, 1:2] <- click(xy = T)[1:2]
#   options(warn = 0)
# }
chart.coords <- locator(n = 24, type = "p")
chart.coords <- cbind(chart.coords[[1]], chart.coords[[2]])
colnames(chart.coords) <- c("x", "y")
sp.chart <- sp::SpatialPoints(chart.coords)
chart_buff <-
rgeos::gBuffer(sp.chart, width = samp.width, byid = T)
# plot(chart_buff, add = T, col = "green")
plot(chart_buff, add = T, col = "green")
return(chart_buff)
# }
#
# chart <- chartf(pic.path = pic.path,
#                 samp.width = samp.width,
#                 pic.format = pic.format)
#
# # plot(chart, add = T, col = "green")
#
# return(chart)
}
## get chart tiles positions using chart2 function--------------------------------
chart <- chart2(pic.path= pic_wd,
pic.format = "jpg")
dev.off()
chart
saveRDS(chart, "chart.rds")
chart <- readRDS("chart.rds")
getwd()
dir.exists("results")
# save chart object in results folder
if(dir.exists("results")==F){
dir.create("results")
}
saveRDS(chart, "./results/chart.rds")
knitr::include_graphics("working_directory_structure.png")
knitr::include_graphics("OCN-example.jpg")
knitr::include_graphics("mask-example.jpg")
## install librarian
if(require(librarian)==F){
install.packages("librarian")
library(librarian)
}else{
library(librarian)
}
# install required packages an libraries
librarian::shelf(MMolbus/CIDE, MMolbus/MButils )
# define sample picture (JPG) directory
pic_wd <-
list.dirs(getwd(), recursive = T)[
grep("JPG$",  list.dirs(getwd(), recursive = T))
]
# define (mask) directory
roi_wd <-
list.dirs(getwd(), recursive = T)[
grep("rois$",  list.dirs(getwd(), recursive = T))
]
## get chart tiles positions using chart2 function--------------------------------
chart <- readRDS("chart.rds")
knitr::include_graphics("chart.jpg")
# create results folder
if(dir.exists("results")==F){
dir.create("results")
}
# save chart as rds file
saveRDS(chart, "./results/chart.rds")
getwd()
msk_name <- list.files(path = roi_wd, pattern=".tif$",full.names = T, recursive = T)
msk_name
roi_wd
pic_wd
pic_wd <-
list.dirs(wd, recursive = T)[
grep("JPG$",  list.dirs(wd, recursive = T))
]
pic_wd
# roi directory
roi_wd <-
list.dirs(wd, recursive = T)[
grep("rois$",  list.dirs(wd, recursive = T))
]
roi_wd
msk_name <- list.files(path = roi_wd, pattern=".tif$",full.names = T, recursive = T)
msk_name
msk_name <-
list.files(path = roi_wd, pattern=".tif$",full.names = T, recursive = T)
##import masks rasters as list
# msk_list <-
# lapply(seq_along(msk_name), function(i)
#   tif2raster(msk_name[i]))
obs.areas <-
lapply(seq_along(msk_name), function(i)
tif2raster(msk_name[i]))
obs.areas
plot(obs.areas[[1]])
